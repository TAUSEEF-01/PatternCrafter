Pattern 1: Singleton Pattern --> users_collection, projects_collection, tasks_collection

async def create_indexes():
    """Create database indexes for better performance"""
    await users_collection.create_index("email", unique=True)
    await users_collection.create_index("role")


// for creating unique ids 






Pattern 2: Adapter Pattern --> Adapter Pattern: ObjectId to JSON Conversion Pipeline


def _stringify_object_ids(value):
    if isinstance(value, ObjectId):
        return str(value)
    if isinstance(value, list):
        return [_stringify_object_ids(v) for v in value]
    if isinstance(value, dict):
        return {k: _stringify_object_ids(v) for k, v in value.items()}
    return value




def as_response(model_cls, doc: Dict[str, Any]):
    """Return an instance of model_cls with all ObjectIds converted to strings and aliases preserved."""
    data = _stringify_object_ids(doc)
    return model_cls(**data)


# backend/schemas.py (PyObjectId)

from bson import ObjectId
from pydantic_core import core_schema

class PyObjectId(ObjectId):
    @classmethod
    def __get_pydantic_core_schema__(cls, _source_type, _handler):
        return core_schema.no_info_plain_validator_function(cls.validate)

    @classmethod
    def validate(cls, v):
        if isinstance(v, ObjectId):
            return v
        if isinstance(v, (str, bytes)):
            s = v.decode() if isinstance(v, bytes) else v
            if ObjectId.is_valid(s):
                return ObjectId(s)
        raise ValueError("Invalid ObjectId")

    @classmethod
    def __get_pydantic_json_schema__(cls, core_schema_, handler):
        json_schema = handler(core_schema_)
        json_schema.update(type="string")
        return json_schema






Pattern 3: Front Controller Pattern --> provides a centralized entry point for all incoming requests

# routes.py (Front Controller aggregator)
from fastapi import APIRouter

import auth_routes
import user_routes
import project_routes
import task_routes
import invite_routes
import notification_routes

router = APIRouter()

router.include_router(auth_routes.router, tags=["Authentication"])
router.include_router(user_routes.router, tags=["Users"])
router.include_router(project_routes.router, tags=["Projects"])
router.include_router(task_routes.router, tags=["Tasks"])
router.include_router(invite_routes.router, tags=["Invites"])
router.include_router(notification_routes.router, tags=["Notifications"])




Pattern 4: Observer Pattern --> 

– frontend/src/providers/NotificationsProvider.tsx– Publisher
– frontend/src/components/NotificationBell.tsx– Subscriber

– NOTIFICATION UNREAD EVENT = ’notifications:unreadCount’
- NOTIFICATION LIST EVENT = ’notifications:list’





Pattern 5: Strategy Pattern -->  The Strategy pattern defines a family of algorithms, encapsulates each one


# backend/schemas.py (TaskCategory enum snippet)
class TaskCategory(str, Enum):
    IMAGE_CLASSIFICATION = "image_classification"
    TEXT_CLASSIFICATION = "text_classification"
    OBJECT_DETECTION = "object_detection"
    NER = "named_entity_recognition"
    LLM_RESPONSE_GRADING = "generative_ai_llm_response_grading"
    CHATBOT_MODEL_ASSESSMENT = "generative_ai_chatbot_assessment"
    RESPONSE_SELECTION = "conversational_ai_response_selection"



# backend/utils.py
from schemas import (
    LLMResponseGradingData,
    ChatbotModelAssessmentData,
    ResponseSelectionData,
    ImageClassificationData,
    TextClassificationData,
    ObjectDetectionData,
    NERData,
    LLMResponseGradingAnnotation,
    ChatbotModelAssessmentAnnotation,
    ResponseSelectionAnnotation,
    ImageClassificationAnnotation,
    TextClassificationAnnotation,
    ObjectDetectionAnnotation,
    NERAnnotation,
)

from schemas import TaskCategory
DATA_MODEL_BY_CATEGORY = {
    TaskCategory.LLM_RESPONSE_GRADING: LLMResponseGradingData,
    TaskCategory.CHATBOT_MODEL_ASSESSMENT: ChatbotModelAssessmentData,
    TaskCategory.RESPONSE_SELECTION: ResponseSelectionData,
    TaskCategory.IMAGE_CLASSIFICATION: ImageClassificationData,
    TaskCategory.TEXT_CLASSIFICATION: TextClassificationData,
    TaskCategory.OBJECT_DETECTION: ObjectDetectionData,
    TaskCategory.NER: NERData,
}

ANNOTATION_MODEL_BY_CATEGORY = {
    TaskCategory.LLM_RESPONSE_GRADING: LLMResponseGradingAnnotation,
    TaskCategory.CHATBOT_MODEL_ASSESSMENT: ChatbotModelAssessmentAnnotation,
    TaskCategory.RESPONSE_SELECTION: ResponseSelectionAnnotation,
    TaskCategory.IMAGE_CLASSIFICATION: ImageClassificationAnnotation,
    TaskCategory.TEXT_CLASSIFICATION: TextClassificationAnnotation,
    TaskCategory.OBJECT_DETECTION: ObjectDetectionAnnotation,
    TaskCategory.NER: NERAnnotation,
}





